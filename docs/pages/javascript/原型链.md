## 原型链

#### 一、原型链

![原型链图片](/images/chain2.png)

- 每一个`构造函数`（实际上就是普通函数，只不过通过`new关键字`调用的时候，就成了构造函数）都对应有一个原型对象（`F.prototype`）;
- 每一个实例都对应有一个`__proto__`属性指向它的原型对象;
- 每一个原型对象(`F.prototype`)都是`Object`的一个实例(`可以看作同其他普通对象一样通过 new Object()生成`)，所以每一个原型对象的`__proto__`均指向`Object.prototype`;
- 每一个构造函数（`包括自定义函数，内置函数（Object()、Number()、String()...）`）都可以看作是通过`new Function()`方式而来，它们都算是`Function`的实例，所以它们的`__proto__`属性均指向`Function.prototype`。


#### 二、`_proto_`(`[[prototype]]`) 和 `prototype` 的区别
- `__proto__`是每个`对象`都有的一个属性，而`prototype`是`函数`才会有的属性。
- *对象* 具有属性`_proto_`,也称为`隐式原型`。
 (一个对象的`隐式原型`指向`构造该对象的构造函数的原型`，这也保证了实例能够访问在构造函数原型中定义的属性和方法)。
- *构造函数* 具有属性 `prototype`。
- 方法（`Function`）比较特殊，既是函数也是对象，所以除了有属性`__proto__`,还有属性`prototype`。
<!-- - 实例函数的`_proto_`和`prototype`都指向的是原型函数 -->
- ES5中用`Object.getPrototypeOf`函数获得一个对象的`[[prototype]]`。ES6中，使用`Object.setPrototypeOf`可以直接修改一个对象的`[[prototype]]`

#### 三、`instanceOf`操作符
- instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的：
```js
// L instanceof R 
//通过判断
 L.__proto__.__proto__ ..... === R.prototype ？
//最终返回true or false

/**
 * 模拟实现instanceof
 */
function instanceFn(L, R) {
    //#1 取出R的原型
    const O = R.prototype;
​
    //#2 取L的隐式原型，依次在原型链上判断
    L = L.__proto__;
    while(true) {
        if (L === null) {
            //#3 当L为空时，返回false
            return false;
        } else {
            //#4 当O与L相等是，说明继承于R
            if (O === L) {
                return true;
            }
            L = L._proto_;
        }
    }
}
```
也就是沿着L的`__proto__`一直寻找到原型链末端，直到等于R.prototype为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了.
```js
Function instanceof Object // true 
 Object instanceof Function // true 
 Function instanceof Function //true
 Object instanceof Object // true
 Number instanceof Number //false
```

## 继承

#### 1. 组合式继承（原型链继承+构造函数继承）

```js
function Parent(name) {
   this.name = name
   this.colors = ["red", "blue", "yellow"]
}
Parent.prototype.sayName = function () {
   console.log(this.name);
}

function Child(name, age) {
   // 继承父类属性(构造函数继承)
   Parent.call(this, name)
   this.age = age;
}
// 继承父类方法（原型链继承）
Child.prototype = new Parent();

Child.prototype.sayAge = function () {
   console.log(this.age);
}
```

#### 2. 寄生式组合式继承

```js
// Object.create()模拟实现
function objectCopy(obj) {
  function Fun() { };
  Fun.prototype = obj;
  return new Fun();
}

function inheritPrototype(child, parent) {
  let prototype = objectCopy(parent.prototype); // 创建对象
  // let prototype = Object.create(parent.prototype) 

  prototype.constructor = child; // 增强对象
  Child.prototype = prototype; // 赋值对象
}

function Parent(name) {
  this.name = name;
  this.friends = ["rose", "lily", "tom"]
}

Parent.prototype.sayName = function () {
  console.log(this.name);
}

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

inheritPrototype(Child, Parent);
Child.prototype.sayAge = function () {
  console.log(this.age);
}

let child1 = new Child("yhd", 23);
child1.sayAge(); // 23
child1.sayName(); // yhd
child1.friends.push("jack");
console.log(child1.friends); // ["rose", "lily", "tom", "jack"]

let child2 = new Child("yl", 22)
child2.sayAge(); // 22
child2.sayName(); // yl
console.log(child2.friends); // ["rose", "lily", "tom"]
```

## 类

#### ES5定义类

```js
//定义Animal类
function Animal(name) {
    this.name = name;
    this.sleep = function() {
        console.log(this.name + '正在睡觉');
    }
}
Animal.prototype = {
    eat: function(food) {
        console.log(this.name + "正在吃" + food);
    }
}
function Cat() {}
Cat.prototype = new Animal('Tom');  //继承
var Tom = new Cat('Tom'); //Cat实例对象
//原型链：Tom(Cat实例对象)--->Cat.prototype(Animal实例对象)--->Animal.prototype--->Object.prototype--->null
```

#### ES6定义类

定义一个类的方法实际上也是上面所说的定义一个对象的方法，类本身就是一个对象，只不过这个对象里面的`方法`和`属性`可以供许多实例对象调用而已。类实质上是 JavaScript 现有的`基于原型的继承的语法糖`。
  
```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  sleep() {
    console.log(this.name + ' 正在睡觉');
  }
  eat(food){
    console.log(this.name+'正在吃'+food)  
  }
}

class Cat extends Animal {  //继承

}

const Tom = new Cat('Tom');
```
#### class继承与ES5继承的区别？

- 类的内部定义的所有方法，都是`不可枚举`的；
- ES6的class类必须用new命令操作，而ES5的构造函数不用new也可以执行；
- ES6的class类`不存在变量提升`，必须先定义class之后才能实例化，不像ES5中可以将构造函数写在实例化之后；
- ES5 的继承，实质是**先创造子类的实例对象this**，然后**再将父类的方法添加到this上面**。ES6 的继承机制完全不同，实质是**先将父类实例对象的属性和方法加到this上面**（所以必须先调用super方法），然后**再用子类的构造函数修改this**。

#### `class类` 与 `传统的基于函数的类`中`this`指向的不同

基于`class`,如果该对象没有`this`值（或`this`作为布尔，字符串，数字，未定义或null) ，那么`this`值在被调用的函数内部将为`undefined`。不会发生`自动包装`。

```js
class Animal { 
  speak() {
    return this;
  }
  static eat() {
    return this;
  }
}

let obj = new Animal();
obj.speak(); // Animal {}
let speak = obj.speak;
speak(); // undefined

Animal.eat() // class Animal
let eat = Animal.eat;
eat(); // undefined
```
基于传统的类,基于调用该函数的`this`值将发生自动装箱。

```js
function Animal() { }

Animal.prototype.speak = function() {
  return this;
}

Animal.eat = function() {
  return this;
}

let obj = new Animal();
let speak = obj.speak;
speak(); // Window

let eat = Animal.eat;
eat(); // Window
```
#### 类不能继承常规（非可构造）对象。如果要继承常规对象，可以改用`Object.setPrototypeOf()`：

```js
var Animal = {
  speak() {
    console.log(this.name + ' makes a noise.');
  }
};

class Dog {
  constructor(name) {
    this.name = name;
  }
}

Object.setPrototypeOf(Dog.prototype, Animal);

var d = new Dog('Mitzie');
d.speak(); // Mitzie makes a noise.
```


